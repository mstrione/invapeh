{"version":3,"sources":["../es6/Observable.js"],"names":[],"mappings":";;;;;;;;0BAAuB,cAAc;;;;wBAChB,aAAa;;qCACT,0BAA0B;;;;;;;;;;;IAO9B,UAAU;;;;;;;;;AAQhB,aARM,UAAU,CAQf,SAAS,EAAE;8BARN,UAAU;;AASvB,YAAI,CAAC,SAAS,GAAG,KAAK,CAAC;AACvB,YAAI,SAAS,EAAE;AACX,gBAAI,CAAC,UAAU,GAAG,SAAS,CAAC;SAC/B;KACJ;;;;;;;;;;;;;;;;;;;;AAbgB,cAAU,WAqB3B,IAAI,GAAA,cAAC,QAAQ,EAAE;AACX,YAAM,UAAU,GAAG,IAAI,UAAU,EAAE,CAAC;AACpC,kBAAU,CAAC,MAAM,GAAG,IAAI,CAAC;AACzB,kBAAU,CAAC,QAAQ,GAAG,QAAQ,CAAC;AAC/B,eAAO,UAAU,CAAC;KACrB;;;;;;;;AA1BgB,cAAU,iDAgCb,YAAG;AACb,eAAO,IAAI,CAAC;KACf;;;;;;;;;;;;;;AAlCgB,cAAU,WA8C3B,SAAS,GAAA,mBAAC,cAAc,EAAE,KAAK,EAAE,QAAQ,EAAE;AACvC,YAAI,UAAU,YAAA,CAAC;AACf,YAAI,cAAc,IAAI,OAAO,cAAc,KAAK,QAAQ,EAAE;AACtD,gBAAI,cAAc,mCAAsB,EAAE;AACtC,0BAAU,GAAG,cAAc,CAAC;aAC/B,MACI;AACD,0BAAU,GAAG,4BAAe,cAAc,CAAC,CAAC;aAC/C;SACJ,MACI;AACD,gBAAM,IAAI,GAAG,cAAc,CAAC;AAC5B,sBAAU,GAAG,wBAAW,MAAM,CAAC,IAAI,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;SACzD;AACD,kBAAU,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC;AAC5C,eAAO,UAAU,CAAC;KACrB;;;;;;;;;;AA9DgB,cAAU,WAsE3B,OAAO,GAAA,iBAAC,IAAI,EAAE,WAAW,EAAE;;;AACvB,YAAI,CAAC,WAAW,EAAE;AACd,gBAAI,eAAK,EAAE,IAAI,eAAK,EAAE,CAAC,MAAM,IAAI,eAAK,EAAE,CAAC,MAAM,CAAC,OAAO,EAAE;AACrD,2BAAW,GAAG,eAAK,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC;aACxC,MACI,IAAI,eAAK,OAAO,EAAE;AACnB,2BAAW,GAAG,eAAK,OAAO,CAAC;aAC9B;SACJ;AACD,YAAI,CAAC,WAAW,EAAE;AACd,kBAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;SAC5C;AACD,eAAO,IAAI,WAAW,CAAC,UAAC,OAAO,EAAE,MAAM,EAAK;AACxC,kBAAK,SAAS,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;SACzC,CAAC,CAAC;KACN;;AArFgB,cAAU,WAsF3B,UAAU,GAAA,oBAAC,UAAU,EAAE;AACnB,eAAO,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;KACjE;;WAxFgB,UAAU;;;qBAAV,UAAU;AAmG/B,UAAU,CAAC,MAAM,GAAG,UAAC,SAAS,EAAK;AAC/B,WAAO,IAAI,UAAU,CAAC,SAAS,CAAC,CAAC;CACpC,CAAC","file":"Observable.js","sourcesContent":["import Subscriber from './Subscriber';\nimport { root } from './util/root';\nimport $$observable from './util/Symbol_observable';\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport default class Observable {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is\n     * called when the Observable is initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or `complete` can be called to notify\n     * of a successful completion.\n     */\n    constructor(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @returns {Observable} a new observable with the Operator applied\n     * @description creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     */\n    lift(operator) {\n        const observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    }\n    /**\n     * @method Symbol.observable\n     * @returns {Observable} this instance of the observable\n     * @description an interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     */\n    [$$observable]() {\n        return this;\n    }\n    /**\n     * @method subscribe\n     * @param {Observer|Function} observerOrNext (optional) either an observer defining all functions to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled\n     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n     * @returns {Subscription} a subscription reference to the registered handlers\n     * @description registers handlers for handling emitted values, error and completions from the observable, and\n     *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n     */\n    subscribe(observerOrNext, error, complete) {\n        let subscriber;\n        if (observerOrNext && typeof observerOrNext === \"object\") {\n            if (observerOrNext instanceof Subscriber) {\n                subscriber = observerOrNext;\n            }\n            else {\n                subscriber = new Subscriber(observerOrNext);\n            }\n        }\n        else {\n            const next = observerOrNext;\n            subscriber = Subscriber.create(next, error, complete);\n        }\n        subscriber.add(this._subscribe(subscriber));\n        return subscriber;\n    }\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} PromiseCtor? a constructor function used to instantiate the Promise\n     * @returns {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    forEach(next, PromiseCtor) {\n        if (!PromiseCtor) {\n            if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n                PromiseCtor = root.Rx.config.Promise;\n            }\n            else if (root.Promise) {\n                PromiseCtor = root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor((resolve, reject) => {\n            this.subscribe(next, reject, resolve);\n        });\n    }\n    _subscribe(subscriber) {\n        return this.source._subscribe(this.operator.call(subscriber));\n    }\n}\n// HACK: Since TypeScript inherits static properties too, we have to\n// fight against TypeScript here so Subject can have a different static create signature\n/**\n * @static\n * @method create\n * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n * @returns {Observable} a new cold observable\n * @description creates a new cold Observable by calling the Observable constructor\n */\nObservable.create = (subscribe) => {\n    return new Observable(subscribe);\n};\n//# sourceMappingURL=Observable.js.map"]}