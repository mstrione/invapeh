{"version":3,"sources":["../../es6/operators/bufferCount.js"],"names":[],"mappings":"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","file":"bufferCount.js","sourcesContent":["import Subscriber from '../Subscriber';\n/**\n * buffers a number of values from the source observable by `bufferSize` then emits the buffer and clears it, and starts a\n * new buffer each `startBufferEvery` values. If `startBufferEvery` is not provided or is `null`, then new buffers are\n * started immediately at the start of the source and when each buffer closes and is emitted.\n * @param {number} bufferSize the maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] optional interval at which to start a new buffer. (e.g. if `startBufferEvery` is `2`,asdf then a\n *   new buffer will be started on every other value from the source.) A new buffer is started at the beginning of the source by default.\n * @returns {Observable<T[]>} an observable of arrays of buffered values.\n */\nexport default function bufferCount(bufferSize, startBufferEvery = null) {\n    return this.lift(new BufferCountOperator(bufferSize, startBufferEvery));\n}\nclass BufferCountOperator {\n    constructor(bufferSize, startBufferEvery) {\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n    }\n    call(subscriber) {\n        return new BufferCountSubscriber(subscriber, this.bufferSize, this.startBufferEvery);\n    }\n}\nclass BufferCountSubscriber extends Subscriber {\n    constructor(destination, bufferSize, startBufferEvery) {\n        super(destination);\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        this.buffers = [[]];\n        this.count = 0;\n    }\n    _next(value) {\n        const count = (this.count += 1);\n        const destination = this.destination;\n        const bufferSize = this.bufferSize;\n        const startBufferEvery = (this.startBufferEvery == null) ? bufferSize : this.startBufferEvery;\n        const buffers = this.buffers;\n        const len = buffers.length;\n        let remove = -1;\n        if (count % startBufferEvery === 0) {\n            buffers.push([]);\n        }\n        for (let i = 0; i < len; i++) {\n            let buffer = buffers[i];\n            buffer.push(value);\n            if (buffer.length === bufferSize) {\n                remove = i;\n                destination.next(buffer);\n            }\n        }\n        if (remove !== -1) {\n            buffers.splice(remove, 1);\n        }\n    }\n    _error(err) {\n        this.destination.error(err);\n    }\n    _complete() {\n        const destination = this.destination;\n        const buffers = this.buffers;\n        while (buffers.length > 0) {\n            let buffer = buffers.shift();\n            if (buffer.length > 0) {\n                destination.next(buffer);\n            }\n        }\n        destination.complete();\n    }\n}\n//# sourceMappingURL=bufferCount.js.map"]}